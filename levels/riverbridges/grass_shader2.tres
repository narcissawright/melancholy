[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[ext_resource path="res://levels/riverbridges/texture/grass_seamless_1.jpg" type="Texture" id=1]
[ext_resource path="res://levels/riverbridges/texture/earthrocks_albedo.png" type="Texture" id=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode blend_mix;

uniform float block_size;
uniform sampler2D aabb_data : hint_albedo;
uniform sampler2D collision_data : hint_albedo;
uniform sampler2D grass_texture : hint_albedo;
uniform sampler2D dirt_texture : hint_albedo;

//int get_relevant_aabb(vec3 point) {
//	int aabb_count = textureSize(aabb_data, 0).y;
//	ivec3 offset = ivec3(32768,32768,32768); // added offset from gdscript
//	for (int i = 0; i < aabb_count; i++) {   // loop over each bounding box
//		ivec4 x = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(0,i), 0)); // grab position
//		ivec4 y = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(1,i), 0));
//		ivec4 z = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(2,i), 0));
//		vec3 box_pos = vec3(ivec3(x.r*256+x.g, y.r*256+y.g, z.r*256+z.g) - offset); // store position as vec3
//		x = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(3,i), 0)); // grab size
//		y = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(4,i), 0));
//		z = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(5,i), 0));
//		vec3 box_size = vec3(ivec3(x.r*256+x.g, y.r*256+y.g, z.r*256+z.g) - offset); // store size as vec3
//		if ( // check if point is inside of the bounding box, if so, return index
//			(point.x >= box_pos.x && point.x <= box_pos.x + box_size.x) &&
//			(point.y >= box_pos.y && point.y <= box_pos.y + box_size.y) &&
//			(point.z >= box_pos.z && point.z <= box_pos.z + box_size.z)
//		) { return i; }
//	}
//	return -1; // no relevant aabb found
//}

float get_pixel(vec3 position) {
	vec3 box_pos;
	vec3 box_size;
	int aabb_count = textureSize(aabb_data, 0).y;
	int relevant_aabb = -1;
	ivec3 value_offset = ivec3(32768,32768,32768); // added offset from gdscript
	for (int i = 0; i < aabb_count; i++) {   // loop over each bounding box
		ivec4 x = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(0,i), 0)); // grab position
		ivec4 y = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(1,i), 0));
		ivec4 z = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(2,i), 0));
		box_pos = vec3(ivec3(x.r*256+x.g, y.r*256+y.g, z.r*256+z.g) - value_offset); // store position as vec3
		x = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(3,i), 0)); // grab size
		y = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(4,i), 0));
		z = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(5,i), 0));
		box_size = vec3(ivec3(x.r*256+x.g, y.r*256+y.g, z.r*256+z.g) - value_offset); // store size as vec3
		if ( // check if point is inside of the bounding box
			(position.x >= box_pos.x && position.x <= box_pos.x + box_size.x) &&
			(position.y >= box_pos.y && position.y <= box_pos.y + box_size.y) &&
			(position.z >= box_pos.z && position.z <= box_pos.z + box_size.z)) 
		{ 
			relevant_aabb = i;
			break; // relevant aabb was found, so break out of the for loop.
		}
	}
	if (relevant_aabb == -1) {
		return 0.0;
	}
	
	// obtain data offset
	ivec4 left  = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(6,relevant_aabb), 0));
	ivec4 right = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(7,relevant_aabb), 0));
	int data_offset = right.g + right.r*256 + left.g*65536 + left.r*16777216;
	
	// it's time to find the data index
	vec3 diff = position - box_pos;
	float max_x = box_size.x / block_size;
	float max_y = box_size.y / block_size;
	float x_component = diff.x / block_size;
	float y_component = diff.y / block_size;
	float z_component = diff.z / block_size;
	
	int index = int(x_component + y_component * max_x + z_component * max_x * max_y);
	index += data_offset;
	
	// now find the pixel index and channel
	int channel = index % 3;
	int pixel_index = index / 3;
	
	// and get data
	if (channel == 0) {
		return texelFetch (collision_data, ivec2(pixel_index % 8192, pixel_index / 8192), 0).r;
	} else if (channel == 1) {
		return texelFetch (collision_data, ivec2(pixel_index % 8192, pixel_index / 8192), 0).g;
	} else {
		return texelFetch (collision_data, ivec2(pixel_index % 8192, pixel_index / 8192), 0).b;
	}
}

float calc_texture(vec3 vertex) {
	vec3 rounded_pos = round(vertex / block_size) * block_size;
	rounded_pos += (vec3(block_size, block_size, block_size) * 0.5);
	float x_sign = sign(vertex.x - rounded_pos.x);
	float y_sign = sign(vertex.y - rounded_pos.y);
	float z_sign = sign(vertex.z - rounded_pos.z);
	if (x_sign == 0.0) { x_sign = 1.0; }
	if (y_sign == 0.0) { y_sign = 1.0; }
	if (z_sign == 0.0) { z_sign = 1.0; }
	
	vec3 position1 = rounded_pos;
	vec3 position2 = rounded_pos + vec3(   0.0,    0.0, z_sign) * block_size;
	vec3 position3 = rounded_pos + vec3(     0, y_sign,      0) * block_size;
	vec3 position4 = rounded_pos + vec3(     0, y_sign, z_sign) * block_size;
	vec3 position5 = rounded_pos + vec3(x_sign,      0,      0) * block_size;
	vec3 position6 = rounded_pos + vec3(x_sign,      0, z_sign) * block_size;
	vec3 position7 = rounded_pos + vec3(x_sign, y_sign,      0) * block_size;
	vec3 position8 = rounded_pos + vec3(x_sign, y_sign, z_sign) * block_size;
	
	float w1 = max(block_size - length(vertex - position1), 0.0);
	float w2 = max(block_size - length(vertex - position2), 0.0);
	float w3 = max(block_size - length(vertex - position3), 0.0);
	float w4 = max(block_size - length(vertex - position4), 0.0);
	float w5 = max(block_size - length(vertex - position5), 0.0);
	float w6 = max(block_size - length(vertex - position6), 0.0);
	float w7 = max(block_size - length(vertex - position7), 0.0);
	float w8 = max(block_size - length(vertex - position8), 0.0);
	
	float weight_total = w1 + w2 + w3 + w4 + w5 + w6 + w7 + w8;
	w1 = w1 / weight_total;
	w2 = w2 / weight_total;
	w3 = w3 / weight_total;
	w4 = w4 / weight_total;
	w5 = w5 / weight_total;
	w6 = w6 / weight_total;
	w7 = w7 / weight_total;
	w8 = w8 / weight_total;
	
	float v1 = get_pixel(position1);
	float v2 = get_pixel(position2);
	float v3 = get_pixel(position3);
	float v4 = get_pixel(position4);
	float v5 = get_pixel(position5);
	float v6 = get_pixel(position6);
	float v7 = get_pixel(position7);
	float v8 = get_pixel(position8);
	
	float final_value = (v1 * w1) + (v2 * w2) + (v3 * w3) + (v4 * w4) + (v5 * w5) + (v6 * w6) + (v7 * w7) + (v8 * w8);
	
	return final_value;
}

void fragment() {
	float textureblend = 0.0; // 0.0 for grass, 1.0 for dirt
	vec3 world_vertex = (CAMERA_MATRIX * vec4(VERTEX, 1.0)).xyz;
	textureblend = calc_texture(world_vertex);

//	if (offset == 6636800) {
//		textureblend = 0.333;
//	}
//	if (relevant_aabb == -1) {
//		textureblend = 0.0;
//	} else if (relevant_aabb == 0) {
//		textureblend = 0.3333;
//	} else if (relevant_aabb == 1) {
//		textureblend = 0.6666;
//	} else if (relevant_aabb == 2) {
//		textureblend = 1.0
//	}
	
	vec4 albedo_grass = texture(grass_texture,UV);
	vec4 albedo_dirt = texture(dirt_texture,UV);
	
	ALBEDO = mix(albedo_grass.rgb, albedo_dirt.rgb, textureblend);
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	SPECULAR = 0.5;
}
"

[resource]
shader = SubResource( 1 )
shader_param/block_size = null
shader_param/grass_texture = ExtResource( 1 )
shader_param/dirt_texture = ExtResource( 2 )
