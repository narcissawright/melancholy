[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[ext_resource path="res://levels/riverbridges/texture/grass_seamless_1.jpg" type="Texture" id=1]
[ext_resource path="res://levels/riverbridges/texture/earthrocks_albedo.png" type="Texture" id=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode blend_mix;

uniform sampler2D aabb_data : hint_albedo;
uniform sampler2D collision_data : hint_albedo;
uniform sampler2D grass_texture : hint_albedo;
uniform sampler2D dirt_texture : hint_albedo;

//bool is_point_in_aabb(ivec3 point, ivec3 box_pos, ivec3 box_size) {
//	return (point.x >= box_pos.x && point.x <= box_pos.x + box_size.x) &&
//		(point.y >= box_pos.y && point.y <= box_pos.y + box_size.y) &&
//		(point.z >= box_pos.z && point.z <= box_pos.z + box_size.z);
//}

float get_pixel(ivec3 position) {
	
	int boundingbox;
	return 0.0;
//	if (is_point_in_aabb(position, ivec3(aabb1pos), ivec3(aabb1size))) {
//		boundingbox = 1;
//	} else if (is_point_in_aabb(position, ivec3(aabb2pos), ivec3(aabb2size))) {
//		boundingbox = 2;
//	} else if (is_point_in_aabb(position, ivec3(aabb3pos), ivec3(aabb3size))) {
//		boundingbox = 3;
//	}
	
	
	
//	int max_x = int(aabb_size.x);
//	int max_y = int(aabb_size.y);
//	ivec3 diff = position - ivec3(aabb_position);
//	int index = diff.x + (diff.y * max_x) + (diff.z * max_x * max_y);
//	int index = 0;
//	return texelFetch (collision_data, ivec2(index % 1024, index / 1024), 0).r;
}

float calc_texture(vec3 vertex) {
	
	vec3 rounded_vertex = round(vertex);
	
	int x_sign = int(sign(vertex.x - rounded_vertex.x));
	int y_sign = int(sign(vertex.y - rounded_vertex.y));
	int z_sign = int(sign(vertex.z - rounded_vertex.z));
	
	ivec3 position1 = ivec3(rounded_vertex);
	ivec3 position2 = position1 + ivec3(     0,      0, z_sign);
	ivec3 position3 = position1 + ivec3(     0, y_sign,      0);
	ivec3 position4 = position1 + ivec3(     0, y_sign, z_sign);
	ivec3 position5 = position1 + ivec3(x_sign,      0,      0);
	ivec3 position6 = position1 + ivec3(x_sign,      0, z_sign);
	ivec3 position7 = position1 + ivec3(x_sign, y_sign,      0);
	ivec3 position8 = position1 + ivec3(x_sign, y_sign, z_sign);
	
	float w1 = max(1.0 - length(vertex - vec3(position1)), 0.0);
	float w2 = max(1.0 - length(vertex - vec3(position2)), 0.0);
	float w3 = max(1.0 - length(vertex - vec3(position3)), 0.0);
	float w4 = max(1.0 - length(vertex - vec3(position4)), 0.0);
	float w5 = max(1.0 - length(vertex - vec3(position5)), 0.0);
	float w6 = max(1.0 - length(vertex - vec3(position6)), 0.0);
	float w7 = max(1.0 - length(vertex - vec3(position7)), 0.0);
	float w8 = max(1.0 - length(vertex - vec3(position8)), 0.0);
	
	float weight_total = w1 + w2 + w3 + w4 + w5 + w6 + w7 + w8;
	w1 = w1 / weight_total;
	w2 = w2 / weight_total;
	w3 = w3 / weight_total;
	w4 = w4 / weight_total;
	w5 = w5 / weight_total;
	w6 = w6 / weight_total;
	w7 = w7 / weight_total;
	w8 = w8 / weight_total;
	
	float v1 = get_pixel(position1);
	float v2 = get_pixel(position2);
	float v3 = get_pixel(position3);
	float v4 = get_pixel(position4);
	float v5 = get_pixel(position5);
	float v6 = get_pixel(position6);
	float v7 = get_pixel(position7);
	float v8 = get_pixel(position8);
	
	float final_value = (v1 * w1) + (v2 * w2) + (v3 * w3) + (v4 * w4) + (v5 * w5) + (v6 * w6) + (v7 * w7) + (v8 * w8);
	
	return final_value;
}

bool is_point_in_aabb(vec3 point, vec3 box_pos, vec3 box_size) {
	return (point.x >= box_pos.x && point.x <= box_pos.x + box_size.x) &&
		(point.y >= box_pos.y && point.y <= box_pos.y + box_size.y) &&
		(point.z >= box_pos.z && point.z <= box_pos.z + box_size.z);
}

int get_relevant_aabb(vec3 point, int aabb_count) {
	ivec3 offset = ivec3(32768,32768,32768); // added offset from gdscript
	for (int i = 0; i < aabb_count; i++) {   // loop over each bounding box
		ivec4 x = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(0,i), 0)); // grab position
		ivec4 y = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(1,i), 0));
		ivec4 z = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(2,i), 0));
		vec3 box_pos = vec3(ivec3(x.r*256+x.g, y.r*256+y.g, z.r*256+z.g) - offset); // store position as vec3
		x = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(3,i), 0)); // grab size
		y = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(4,i), 0));
		z = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(5,i), 0));
		vec3 box_size = vec3(ivec3(x.r*256+x.g, y.r*256+y.g, z.r*256+z.g) - offset); // store size as vec3
		if ( // check if point is inside of the bounding box, if so, return index
			(point.x >= box_pos.x && point.x <= box_pos.x + box_size.x) &&
			(point.y >= box_pos.y && point.y <= box_pos.y + box_size.y) &&
			(point.z >= box_pos.z && point.z <= box_pos.z + box_size.z)
		) { return i; }
	}
	return -1; // no relevant aabb found
}

void fragment() {
	float textureblend = 0.0; // 0.0 for grass, 1.0 for dirt
	vec3 world_vertex = (CAMERA_MATRIX * vec4(VERTEX, 1.0)).xyz;
	int aabb_count = textureSize(aabb_data, 0).y;
	int relevant_aabb = get_relevant_aabb(world_vertex, aabb_count);
	
	// obtain data offset
	ivec4 left = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(6,relevant_aabb), 0));
	ivec4 right = ivec4(0.5 + 255.0 * texelFetch(aabb_data, ivec2(7,relevant_aabb), 0));
	int offset = right.g + right.r*256 + left.g*65536 + left.r*16777216;
	if (offset == 6636800) {
		textureblend = 0.333;
	}
	
	
	

//	if (relevant_aabb == -1) {
//		textureblend = 0.0;
//	} else if (relevant_aabb == 0) {
//		textureblend = 0.3333;
//	} else if (relevant_aabb == 1) {
//		textureblend = 0.6666;
//	} else if (relevant_aabb == 2) {
//		textureblend = 1.0
//	}
	
	vec4 albedo_grass = texture(grass_texture,UV);
	vec4 albedo_dirt = texture(dirt_texture,UV);
	
	ALBEDO = mix(albedo_grass.rgb, albedo_dirt.rgb, textureblend);
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	SPECULAR = 0.5;
}
"

[resource]
shader = SubResource( 1 )
shader_param/grass_texture = ExtResource( 1 )
shader_param/dirt_texture = ExtResource( 2 )
